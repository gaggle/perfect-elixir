#!/bin/sh

if test -n "$VERBOSE" -o -n "$GITHUB_ACTIONS" -a -n "$RUNNER_DEBUG"; then
  set -x
fi

about_script() {
  cat <<-EOS
This script bootstraps the development environment for our project, prompting along the way for any necessary dependencies to install, configurations to change, or tools to activate.
EOS
}

must_be_sourced_msg() {
  echo "${tty_underline}${tty_bold}âŒ script must be sourced: \`source bootstrap\`${tty_reset}\n"
  cat <<-EOS
This script cannot be executed directly, as it relies on your actual shell session to test for dependencies and configurations.

Run it as \`${tty_bold}source bootstrap${tty_reset}\` instead, then follow the prompts.

EOS
  echo "${tty_underline}${tty_bold}About this script${tty_reset}\n"
  about_script
  return 1
}

help_msg() {
  about_script
  cat <<-EOS

Usage:
  source bootstrap         Starts the bootstrap process.
  source bootstrap --help  Displays this help message.

Options:
  --help, -h              Show help and usage information.

Environmental Variables:
  VERBOSE                 Enable verbose logging
  NONINTERACTIVE          Assume 'yes' to any prompts

Make sure to run this script by sourcing it, not executing it directly, to ensure it operates within your current shell session's context.
EOS
  return 0
}

if [ -t 1 ]; then
  tty_escape() { printf "\033[%sm" "$1"; }
else
  tty_escape() { :; }
fi

tty_mkbold() { tty_escape "1;$1"; }
tty_red="$(tty_mkbold 31)"
tty_green="$(tty_mkbold 32)"
tty_bold="$(tty_mkbold 39)"
tty_reset="$(tty_escape 0)"
tty_underline="$(tty_escape "4;39")"

########################################################################### utils

confirm() {
  msg="${1:-Ok to proceed?}"

  printf "%s%s%s [%sy%s/%sn%s]: " "$tty_bold" "$msg" "$tty_reset" "$tty_green" "$tty_reset" "$tty_red" "$tty_reset"

  if [ "$NONINTERACTIVE" = "true" ]; then
    echo "Y (non-interactive)"
    return 0
  fi

  while true; do
    read -r reply
    case $reply in
    [Yy]*) return 0 ;;
    [Nn]*) return 1 ;;
    *) echo "Please answer Y or N" ;;
    esac
  done
}

condition() {
  description=$1
  command=$2
  command_output=""

  printf "â€¢ %sâ€¦ " "$description"
  command_output=$(eval "${command}" 2>&1)
  command_exit_code=$?

  printf "%sâœ“%s\n" "$tty_green" "$tty_reset"

  if [ "$DEBUG" = "true" ]; then
    printf "> Executed: %s%s%s (returned %s%s%s)" "$tty_red" "$command" "$tty_reset" "$tty_red" "$command_exit_code" "$tty_reset"
    printf "%s\n" "$command_output"
  fi
  return $command_exit_code
}

fake() {
  eval "val=\"\$fake_$1\""
  if [ -z "$val" ]; then
      return 1
  else
      return 0
  fi
}

return_fake() {
  indirect="fake_$1"
  resolved=$(eval echo "\$$indirect")
  return "$resolved"
}

########################################################################### actions

explain_install_pkgx() {
  echo "${tty_underline}${tty_bold}User action required: Install pkgx${tty_reset}\n"
  cat <<-EOS
You need to install ${tty_bold}pkgx${tty_reset}. Source this script again afterwards.

${tty_bold}pkgx${tty_reset} can be installed in various ways, depending on your preferences:

â€¢ Via ${tty_bold}Homebrew${tty_reset}:
    $ ${tty_bold}brew install pkgxdev/made/pkgx${tty_reset}

â€¢ Via ${tty_bold}cURL${tty_reset}:
    $ ${tty_bold}curl -Ssf https://pkgx.sh | sh${tty_reset}

For other ways to install see: ${tty_bold}${tty_underline}https://docs.pkgx.sh/run-anywhere/terminals${tty_reset}

${tty_bold}pkgx${tty_reset} is the package manager that handles system dependencies, and it is not currently installed. The installation is simple, and via Homebrew does not require sudo or other forms of elevated permissions.

Read more about pkgx on ${tty_bold}${tty_underline}https://pkgx.sh${tty_reset}

Source this script again after pkgx has been installed.
EOS
}

explain_integrate_pkgx() {
  echo "${tty_underline}${tty_bold}User action required: Activate pkgx shell integration${tty_reset}\n"
  cat <<-EOS
You need to activate ${tty_bold}pkgx shell integration${tty_reset}. Source this script again afterwards.

â€¢ Run this command:

    $ ${tty_bold}eval "\$(pkgx integrate)"${tty_reset}

â€¢ You can also inspect what ${tty_bold}integrate${tty_reset} will do by running a dry run:

    $ ${tty_bold}pkgx integrate --dry-run${tty_reset}

Shell integration is required to create "${tty_bold}temporary, isolated package environments${tty_reset}", which is what powers our development environment. Integration writes one line to your ${tty_bold}.shellrc${tty_reset}.

For more information about shell integration see: ${tty_bold}${tty_underline}https://docs.pkgx.sh/using-pkgx/shell-integration${tty_reset}

Source this script again after shell integration has been activated.
EOS
}

explain_clone_repo() {
  echo "${tty_underline}${tty_bold}User action required: Clone gaggle/perfect-elixir repository${tty_reset}\n"
  cat <<-EOS
You need to clone the ${tty_bold}gaggle/perfect-elixir${tty_reset} GitHub repository. Source this script again afterwards.

There are two primary ways to clone a repository:

â€¢ Using ${tty_bold}SSH${tty_reset}:

    $ ${tty_bold}git clone git@github.com:gaggle/perfect-elixir.git${tty_reset}
    $ ${tty_bold}cd perfect-elixir${tty_reset}

â€¢ Using ${tty_bold}HTTPS${tty_reset}:

    $ ${tty_bold}git clone https://github.com/gaggle/perfect-elixir.git${tty_reset}
    $ ${tty_bold}cd perfect-elixir${tty_reset}

Because this script is made for an article the content isn't on ${tty_bold}main${tty_reset}, so after cloning you'll also need to switch branch:

    $ ${tty_bold}git checkout 'perfect-elixir-3-development-workflows-&-processes'${tty_reset}

You can learn more about cloning here: ${tty_bold}${tty_underline}https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories${tty_reset}.

Source this script again after cloning the repository.
EOS
}

explain_activate_dev() {
  echo "${tty_underline}${tty_bold}User action required: Activate developer environment${tty_reset}\n"
  cat <<-EOS
You should run ${tty_bold}dev${tty_reset}, which is the pkgx tool to utilize developer environments. Source this script again afterwards.

â€¢ Run this command:

    $ ${tty_bold}dev${tty_reset}

${tty_bold}dev${tty_reset} only needs to be run once, from then on the folder will be under ${tty_bold}pkgx${tty_reset} supervision and dependencies will be managed automatically.

You can learn more about ${tty_bold}dev${tty_reset} and its usage here: ${tty_bold}${tty_underline}https://docs.pkgx.sh/using-dev/dev${tty_reset}

Source this script again after activating developer environment.
EOS
}

explain_good_to_go() {
  echo "${tty_underline}${tty_bold}Good to go${tty_reset}\n"
  cat <<-EOS
Bootstrapping is done:
${tty_green}âœ“${tty_reset} ${tty_bold}pkgx${tty_reset} is installed
${tty_green}âœ“${tty_reset} Its ${tty_bold}shell integration${tty_reset} is active
${tty_green}âœ“${tty_reset} The ${tty_bold}repository${tty_reset} is cloned and ready
${tty_green}âœ“${tty_reset} All ${tty_bold}system dependencies${tty_reset} are available

This system has been bootstrapped and can now hook into our project ðŸŽ‰

â€¢ Run this command to continue onboarding:

    $ ${tty_bold}bin/doctor${tty_reset}
EOS
}

should_install_pkgx() {
  if fake should_install_pkgx; then
    return_fake should_install_pkgx
  else
    if ! which pkgx >/dev/null; then
      # Pkgx not installed, so yes install
      return 0
    elif pkgx_is_old >/dev/null 2>&1; then
      # Yes install
      return 0
    else
      # Up-to-date pkgx exists, nothing to install
      return 1
    fi
  fi
}

pkgx_is_old() {
  v="$(pkgx --version || echo pkgx 0)"
  pkgx --silent semverator gt \
    "$(curl -Ssf https://pkgx.sh/VERSION)" \
    "$(echo "$v" | awk '{print $2}')"
}



should_integrate_pkgx() {
  if fake should_integrate_pkgx; then
    return_fake should_integrate_pkgx
  else
    if ! which dev >/dev/null || ! which env >/dev/null; then
      # pkgx shell integration commands are not present, so yes integrate
      return 0
    else
      # shell integration commands exists, nothing more to do
      return 1
    fi
  fi
}

should_clone_repo() {
  if fake should_clone_repo; then
    return_fake should_clone_repo
  else
    if [ ! -d ".git" ]; then
      # Not a git repository; clone it.
      return 0
    else
      remote_url="$(git config --get remote.origin.url)"
      if [ "$remote_url" != "git@github.com:gaggle/perfect-elixir.git" ] && [ "$remote_url" != "https://github.com/gaggle/perfect-elixir.git" ]; then
        # Remote URL doesn't match; clone it.
        return 0
      else
        # The repository is the expected one, nothing more to do.
        return 1
      fi
    fi
  fi
}

should_activate_dev() {
   if fake should_activate_dev; then
     return_fake should_activate_dev
   else
     for cmd in erl elixir psql; do
       if ! command -v $cmd >/dev/null; then
         # One of the commands is not installed, so yes, install it.
         return 0
       fi
     done
     # All commands are installed, so no need to install anything.
     return 1
   fi
 }

########################################################################### logic

main() {
  about_script
  printf "\n"
  if confirm "Ok to proceed?"; then
    if condition "Checking for pkgx" "should_install_pkgx"; then
      printf "â€¢ pkgx is not installed %sx%s\n\n" "$tty_red" "$tty_reset"
      explain_install_pkgx
      return 0
    else
      printf "â€¢ pkgx is installed %sâœ“%s\n" "$tty_green" "$tty_reset"
    fi

    if condition "Checking pkgx shell integration" "should_integrate_pkgx"; then
      printf "â€¢ pkgx is not shell integrated %sx%s\n\n" "$tty_red" "$tty_reset"
      explain_integrate_pkgx
      return 0
    else
      printf "â€¢ Shell integration is active %sâœ“%s\n" "$tty_green" "$tty_reset"
    fi

    if condition "Checking for repository" "should_clone_repo"; then
      printf "â€¢ Repository is not available %sx%s\n\n" "$tty_red" "$tty_reset"
      explain_clone_repo
      return 0
    else
      printf "â€¢ Repository is available %sâœ“%s\n" "$tty_green" "$tty_reset"
    fi

    if condition "Checking for dependencies" "should_activate_dev"; then
      printf "â€¢ Dependencies are not available %sx%s\n\n" "$tty_red" "$tty_reset"
      explain_activate_dev
      return 0
    else
      printf "â€¢ Dependencies are available %sâœ“%s\n" "$tty_green" "$tty_reset"
    fi

    printf "\n"
    explain_good_to_go
  else
    return 0
  fi
}

# https://stackoverflow.com/a/28776166/884080
(
  [[ -n $ZSH_VERSION && $ZSH_EVAL_CONTEXT =~ :file$ ]] ||
  [[ -n $KSH_VERSION && "$(cd -- "$(dirname -- "$0")" && pwd -P)/$(basename -- "$0")" != "$(cd -- "$(dirname -- "${.sh.file}")" && pwd -P)/$(basename -- "${.sh.file}")" ]] ||
  [[ -n $BASH_VERSION ]] && (return 0 2>/dev/null)
) && sourced=1 || sourced=0

if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
  help_msg
elif [ "$sourced" = "0" ]; then
  must_be_sourced_msg
else
  main
fi
