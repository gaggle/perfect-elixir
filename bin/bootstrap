#!/bin/sh

if test -n "$VERBOSE" -o -n "$GITHUB_ACTIONS" -a -n "$RUNNER_DEBUG"; then
  set -x
fi

about_script() {
  cat <<EOS
This script bootstraps our development environment,
prompting along the way for any changes that needs to be done.
EOS
}

must_be_sourced_msg() {
  explain "❌ script must be sourced: \`source <script>\`" "$(
    cat <<EOS
This script cannot be executed directly, as it relies on your actual shell session to test for dependencies and configurations.

Run it as ${tty_bold}\`source <script>\`${tty_reset} instead, and follow the prompts.
EOS
  )"
  explain "About script" "$(about_script)"
  return 1
}

if [ -t 1 ]; then
  tty_escape() { printf "\033[%sm" "$1"; }
else
  tty_escape() { :; }
fi

tty_mkbold() { tty_escape "1;$1"; }
tty_red="$(tty_mkbold 31)"
tty_green="$(tty_mkbold 32)"
tty_bold="$(tty_mkbold 39)"
tty_reset="$(tty_escape 0)"
tty_underline="$(tty_escape "4;39")"

########################################################################### utils

confirm() {
  msg="${1:-Ok to proceed?}"

  printf "%s%s%s [%sy%s/%sn%s]: " "$tty_bold" "$msg" "$tty_reset" "$tty_green" "$tty_reset" "$tty_red" "$tty_reset"

  if [ "$NONINTERACTIVE" = "true" ]; then
    echo "Y (non-interactive)"
    return 0
  fi

  while true; do
    read -r reply
    case $reply in
    [Yy]*) return 0 ;;
    [Nn]*) return 1 ;;
    *) echo "Please answer Y or N" ;;
    esac
  done
}

condition() {
  description=$1
  command=$2
  command_output=""

  printf "• %s… " "$description"
  command_output=$(eval "${command}" 2>&1)
  command_exit_code=$?

  printf "%s✓%s\n" "$tty_green" "$tty_reset"

  if [ "$DEBUG" = "true" ]; then
    printf "> Executed: %s%s%s (returned %s%s%s)" "$tty_red" "$command" "$tty_reset" "$tty_red" "$command_exit_code" "$tty_reset"
    printf "%s\n" "$command_output"
  fi
  return $command_exit_code
}

explain() {
  headline_length=$(printf "%s" "$1" | wc -m)
  printf "%s%s%s\n" "$tty_bold" "$1" "$tty_reset"
  printf '%*s\n' "${headline_length}" '' | tr ' ' '─'
  printf "%s\n\n" "$2"
}

fake() {
  eval "val=\"\$fake_$1\""
  if [ -z "$val" ]; then
      return 1
  else
      return 0
  fi
}

return_fake() {
  indirect="fake_$1"
  resolved=$(eval echo "\$$indirect")
  return "$resolved"
}

########################################################################### actions

explain_install_pkgx() {
  explain "User action required: Install pkgx" "$(
    cat <<EOS
You need to install ${tty_bold}pkgx${tty_reset}. Run this script again afterwards.

It can be installed in various ways, depending on your preferences:
• Via ${tty_bold}Homebrew${tty_reset}:
    ${tty_bold}brew install pkgxdev/made/pkgx${tty_reset}

• Via ${tty_bold}cURL${tty_reset}:
    ${tty_bold}curl -Ssf https://pkgx.sh | sh${tty_reset}

For other ways to install see: ${tty_bold}${tty_underline}https://docs.pkgx.sh/run-anywhere/terminals${tty_reset}

${tty_bold}pkgx${tty_reset} is the package manager that handles system dependencies, and it is not currently installed. The installation is simple, and via Homebrew it does not require sudo or other forms of elevated permissions.

Read more about pkgx on ${tty_bold}${tty_underline}https://pkgx.sh${tty_reset}

Run this script again after pkgx has been installed.
EOS
  )"
}

should_install_pkgx() {
  if fake should_install_pkgx; then
    return_fake should_install_pkgx
  else
    if ! which pkgx >/dev/null; then
      # Pkgx not installed, so yes install
      return 0
    elif pkgx_is_old >/dev/null 2>&1; then
      # Yes install
      return 0
    else
      # Up-to-date pkgx exists, nothing to install
      return 1
    fi
  fi
}

pkgx_is_old() {
  v="$(pkgx --version || echo pkgx 0)"
  pkgx --silent semverator gt \
    "$(curl -Ssf https://pkgx.sh/VERSION)" \
    "$(echo "$v" | awk '{print $2}')"
}

explain_integrate_pkgx() {
  explain "User action required: Activate pkgx shell integration" "$(
    cat <<EOS
You need to activate ${tty_bold}pkgx shell integration${tty_reset}. Run this script again afterwards.

• Run this command: ${tty_bold}eval "\$(pkgx integrate)"${tty_reset}

To first see what integrate will do, do a dry run:
  ${tty_bold}pkgx integrate --dry-run${tty_reset}

Shell integration is required to create "${tty_bold}temporary, isolated package environments${tty_reset}", which is what powers our development environment.

For more information about shell integration see: ${tty_bold}${tty_underline}https://docs.pkgx.sh/using-pkgx/shell-integration${tty_reset}

Read more about pkgx on ${tty_bold}${tty_underline}https://pkgx.sh${tty_reset}.

Run this script again after shell integration has been activated.
EOS
  )"
}

should_integrate_pkgx() {
  if fake should_integrate_pkgx; then
    return_fake should_integrate_pkgx
  else
    if ! which dev >/dev/null || ! which env >/dev/null; then
      # pkgx shell integration commands are not present, so yes integrate
      return 0
    else
      # shell integration commands exists, nothing more to do
      return 1
    fi
  fi
}

explain_clone_repo() {
  explain "User action required: Clone gaggle/perfect-elixir repository" "$(
    cat <<EOS
You need to clone the ${tty_bold}gaggle/perfect-elixir${tty_reset} repository. Run this script again afterwards.

There are two primary ways to clone the repository:

• Using ${tty_bold}SSH${tty_reset}:

    ${tty_bold}git clone git@github.com:gaggle/perfect-elixir.git${tty_reset}

• Using ${tty_bold}HTTPS${tty_reset}:

    ${tty_bold}git clone https://github.com/gaggle/perfect-elixir.git${tty_reset}

You can learn more about cloning with ${tty_bold}SSH${tty_reset} here: ${tty_bold}${tty_underline}https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-ssh-urls${tty_reset}
And cloning with ${tty_bold}HTTPS${tty_reset} here: ${tty_bold}${tty_underline}https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls${tty_reset}

Either command creates a new directory named '${tty_bold}perfect-elixir${tty_reset}'.
After cloning the repository, navigate into it with:

    ${tty_bold}cd perfect-elixir${tty_reset}

Run this script again after cloning the repository.
EOS
  )"
}

should_clone_repo() {
  if fake should_clone_repo; then
    return_fake should_clone_repo
  else
    if [ ! -d ".git" ]; then
      # Not a git repository; clone it.
      return 0
    else
      remote_url="$(git config --get remote.origin.url)"
      if [ "$remote_url" != "git@github.com:gaggle/perfect-elixir.git" ] && [ "$remote_url" != "https://github.com/gaggle/perfect-elixir.git" ]; then
        # Remote URL doesn't match; clone it.
        return 0
      else
        # The repository is the expected one, nothing more to do.
        return 1
      fi
    fi
  fi
}

########################################################################### logic

main() {
  about_script
  printf "\n"
  if confirm "Ok to proceed?"; then
    if condition "Checking for pkgx" "should_install_pkgx"; then
      printf "• pkgx is not installed %sx%s\n\n" "$tty_red" "$tty_reset"
      explain_install_pkgx
      return 0
    else
      printf "• pkgx is installed %s✓%s\n" "$tty_green" "$tty_reset"
    fi

    if condition "Checking pkgx shell integration" "should_integrate_pkgx"; then
      printf "• pkgx is not shell integrated %sx%s\n\n" "$tty_red" "$tty_reset"
      explain_integrate_pkgx
      return 0
    else
      printf "• Shell integration is active %s✓%s\n" "$tty_green" "$tty_reset"
    fi

    if condition "Checking for repository" "should_clone_repo"; then
      printf "• Repository is not available %sx%s\n\n" "$tty_red" "$tty_reset"
      explain_clone_repo
      return 0
    else
      printf "• Repository is available %s✓%s\n" "$tty_green" "$tty_reset"
    fi

    explain "Good to go" "$(
      cat <<EOS
Bootstrapping is done: ${tty_bold}\`pkgx\`${tty_reset} is available.

Run ${tty_bold}\`bin/doctor\`${tty_reset} to finish onboarding.
EOS
    )"
  else
    return 0
  fi
}

# https://stackoverflow.com/a/28776166/884080
(
  [[ -n $ZSH_VERSION && $ZSH_EVAL_CONTEXT =~ :file$ ]] ||
  [[ -n $KSH_VERSION && "$(cd -- "$(dirname -- "$0")" && pwd -P)/$(basename -- "$0")" != "$(cd -- "$(dirname -- "${.sh.file}")" && pwd -P)/$(basename -- "${.sh.file}")" ]] ||
  [[ -n $BASH_VERSION ]] && (return 0 2>/dev/null)
) && sourced=1 || sourced=0

if [ "$sourced" = "1" ]; then
  main
else
  must_be_sourced_msg
fi
