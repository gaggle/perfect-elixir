#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "This script must be sourced, not executed directly"
  exit 1
fi

cecho() {
  set -euo pipefail

  local reset="\033[0m" suffix="\n" styles=() output="" is_bright=false param="" color_enabled=true

  if [ ! -t 1 ] && [[ ${FORCE_COLOR:-false} != "true" ]]; then
    # Colors are disabled if STDOUT is not attached to a terminal
    # *unless* FORCE_COLOR is true then colors are preserved regardless
    color_enabled=false
    reset=""
  fi

  cecho_usage() {
    cecho "cecho: echo text with " -b --cyan "color" " and " -bu "style"
    cecho "\nUsage: cecho [options] <text>"
    cecho "\nExample: cecho --red -b \"Hello World\""
    cecho -u "\nTEXT STYLES"
    cecho "  -b, --bold       " -b "Bold or increased intensity"
    cecho "  -f, --faint      " -f "Faint, decreased intensity, or dim"
    cecho "  -i, --italic     " -i "Italic"
    cecho "  -u, --underline  " -u "Underline"
    cecho -u "\nCOLORS"
    local color padding
    for color in black red green yellow blue magenta cyan white; do
      padding=$(printf '%*s' $((12 - ${#color})) "")
      cecho "  --$color $(_padding "$color", 12) " --$color "$color color $(_padding "$color" 8) (" --$color -B "bright" ")"
    done
    cecho "  -B, --bright   Bright color variant"
    cecho -u "\nOTHER"
    cecho "  -n             Do not output the trailing newline"
    cecho "  -h, --help     Show this help and exit"
  }

  declare -A codes=(["--black"]="30" ["--red"]="31" ["--green"]="32" ["--yellow"]="33" ["--blue"]="34" ["--magenta"]="35" ["--cyan"]="36" ["--white"]="37" ["-b"]="1" ["--bold"]="1" ["-f"]="2" ["--faint"]="2" ["-i"]="3" ["--italic"]="3" ["-u"]="4" ["--underline"]="4" ["-n"]="" ["-B"]="")

  apply_styles() {
    for style in "${styles[@]}"; do
      if [[ "$color_enabled" == true ]]; then
        output+="\033[$([[ "$is_bright" == true && "$style" =~ ^3[0-7]$ ]] && echo "9${style: -1}" || echo "$style")m"
      fi
    done
    styles=()
  }

  while (($#)); do
    param="$1"
    shift
    if [[ "$param" == "--help" ]]; then
      cecho_usage
      return 0
    elif [[ "$param" == "-B" ]]; then
      is_bright=true
    elif [[ "$param" == "-n" ]]; then
      suffix=""
    elif [[ "$param" =~ ^-[a-zA-Z]{2,}$ ]]; then # Detect bundled short options
      for ((i = 1; i < ${#param}; i++)); do
        char="-${param:$i:1}"
        if [[ "$char" == "-B" ]]; then
          is_bright=true
        elif [[ "$char" == "-n" ]]; then
          suffix=""
        elif [[ "${codes[$char]+_}" ]]; then
          styles+=("${codes[$char]}")
        else
          echo "Unknown option: $char" >&2
          return 1
        fi
      done
    elif [[ -n "$param" && "${codes[$param]+_}" ]]; then
      styles+=("${codes[$param]}")
    else
      [[ "${#styles[@]}" -ne 0 ]] && apply_styles
      output+="$param$reset"
    fi
  done
  echo -en "${output}${suffix}"
}

clipboard() {
  set -euo pipefail

  clipboard_usage() {
    cecho -b "clipboard" ": copy text to clipboard"
    cecho "\nUsage: clipboard [options] <text>"
    cecho -u "\nEXAMPLES"
    cecho "  $ clipboard foo"
    cecho "  $ echo foo | clipboard"
    cecho -u "\nOPTIONS"
    cecho "  -h, --help      Show this help and exit"
  }

  while (($#)); do
    case "$1" in
    -h | --help)
      clipboard_usage
      return 0
      ;;
    *) break ;;
    esac
  done

  local input
  set +e # `read -t 0` exits non-zero
  if [ -t 0 ]; then
    # STDIN is a terminal, likely no data is piped, use arguments as input
    input="$*"
  else
    # STDIN is not a terminal, attempt to read from it
    input=$(cat) || true  # Ensure any read errors do not cause script exit
  fi
  set -e

  if command -v pbcopy >/dev/null; then
    echo -n "$input" | pbcopy
  else
    cecho --yellow -fn "Warn: Clipboard command not available, tried to copy: "
    cecho --yellow -b "$input"
    return
  fi
}

section() {
  set -euo pipefail
  cecho -Bbu "\n$1"
}

step() {
  set -euo pipefail

  local command="" command_exit_code command_output="" description="" with_output=0

  step_usage() {
    cecho 'Usage:'
    cecho '  step [--with-output] "<DESCRIPTION>" "<COMMAND>"'
    cecho '\nPerforms a step described by DESCRIPTION by executing COMMAND.'
    cecho 'Command output is only shown if command exits non-zero,'
    cecho 'unless --with-output is passed in which case output is displayed'
    cecho 'as the command runs.'
    cecho '\nDEBUG=true forces command output to always be shown after'
    cecho 'execution.'
    cecho '\nExamples:'
    cecho '  $ step "Echo" "echo Hello"'
    cecho '  • Echo ' --green -b '✓'
    cecho '\n  $ step "Read file" "cat foo"'
    cecho '  • Read file ' --red -b 'x'
    cecho --red '  > Executed: ' --red -b 'cat foo'
    cecho --red '  cat: foo: No such file or directory'
  }

  while (("$#")); do
    case "$1" in
    -h | --help)
      step_usage
      return 0
      ;;
    -o | --with-output)
      with_output=1
      shift
      ;;
    -* | --*)
      echo "Error: Unsupported flag $1" >&2
      step_usage
      return 1
      ;;
    *)
      if [[ -z $description ]]; then
        description=$1
      else
        command=$1
      fi
      shift
      ;;
    esac
  done

  if [[ -z $description ]] || [[ -z $command ]]; then
    step_usage
    return 1
  fi

  if ((with_output)); then
    cecho -f ">"
    set +e
    eval "${command}"
    command_exit_code=$?
    set -e
  else
    cecho -n "• ${description}"
    set +e
    command_output=$(eval "${command} 2>&1")
    command_exit_code=$?
    set -e
  fi

  if ((with_output)); then
    if [[ ${command_exit_code} -eq 0 ]]; then
      cecho "• ${description}" --green -bB " ✓"
      debug_log "> Executed: ${command}"
    else
      cecho "• ${description}" --red -bB " x"
      cecho --red "> Executed: " --red -b "${command}"
      debug_log "Done with '${description}', exited ${command_exit_code}"
    fi
  else
    if [[ ${command_exit_code} -eq 0 ]]; then
      cecho --green -bB " ✓"
      debug_log "> Executed: ${command}"
      debug_log "${command_output}"
    else
      cecho --red -bB " x"
      cecho --red "> Executed: " --red -b "${command}"
      cecho --red "${command_output}"
      debug_log "Done with '${description}', exited ${command_exit_code}"
    fi
  fi
  return ${command_exit_code}
}

check() {
  set -euo pipefail

  local command="" command_exit_code description="" remedy=""

  check_usage() {
    cecho "Usage:"
    cecho '  check "<DESCRIPTION>" "<COMMAND>" "<REMEDY>"'
    cecho "\nPerforms a check described by DESCRIPTION by executing COMMAND,"
    cecho 'if the check fails, the proposed REMEDY is shown and copied to'
    cecho 'the clipboard.'
    cecho '\nPlease note DESCRIPTION, COMMAND, and REMEDY should be quoted'
    cecho 'if you use spaces in them.'
    cecho '\nExamples:'
    cecho '  $ check "Can echo?" "echo Hello" "`echo` always works??"'
    cecho '  • Can echo? ' --green -b '✓'
    cecho '\n  $ check "Test if file exist" "[ -f foo ]" "touch foo"'
    cecho '  • Test if file exist ' --red -b 'x'
    cecho --red '  > Executed: ' --red -b '[ -f foo ]'
    cecho --yellow '\n  Suggested remedy: ' --yellow -b 'touch foo'
    cecho --yellow '  (Copied to clipboard)'
  }

  while (($#)); do
    case "$1" in
    -h | --help)
      check_usage
      return 0
      ;;
    -* | --*)
      echo "Error: Unsupported flag $1" >&2
      step_usage
      return 1
      ;;
    *)
      if [[ -z $description ]]; then
        description="$1"
      elif [[ -z $command ]]; then
        command="$1"
      else
        remedy="$1"
      fi
      shift
      ;;
    esac
  done

  if [[ -z $description ]] || [[ -z $command ]] || [[ -z $remedy ]]; then
    step_usage
    return 1
  fi

  cecho -n "• ${description}"

  set +e
  command_output=$(eval "${command} 2>&1")
  command_exit_code=$?
  set -e

  if [[ ${command_exit_code} -eq 0 ]]; then
    cecho --green -bB " ✓"
    debug_log "> Executed: ${command}"
    debug_log "${command_output}"
  else
    cecho --red -bB " x"
    cecho --red "> Executed: " --red -b "${command}"
    [ -n "${command_output}" ] && cecho --red "${command_output}"
    debug_log "Done with '${description}', exited ${command_exit_code}"
    cecho ""
    cecho --yellow "Suggested remedy: " --yellow -b "${remedy}"
    clipboard "${remedy}" && cecho --yellow "(Copied to clipboard)"
  fi
  return ${command_exit_code}
}

debug_log() {
  set -euo pipefail

  if [[ ${DEBUG:-false} == "true" ]]; then
    cecho -f "DEBUG: " "$1"
  fi
}

_padding() {
  local input="$1" total_length="$2"
  local input_length="${#input}"
  local padding_length=$((total_length - input_length))
  printf '%*s' "$padding_length"
}

_pad() {
  local padding=$(_padding "$1" "$2")
  echo -n "$1$padding"
}

_leftpad() {
  local padding=$(_padding "$1" "$2")
  echo -n "$padding$1"
}
