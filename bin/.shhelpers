#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  echo "This script must be sourced, not executed directly"
  exit 1
fi

cecho() {
  set -euo pipefail

  local reset="\033[0m" suffix="\n" styles=() output="" is_bright=false param="" color_enabled=true

  if [ ! -t 1 ] && [[ ${FORCE_COLOR:-false} != "true" ]]; then
    # Colors are disabled if STDOUT is not attached to a terminal
    # *unless* FORCE_COLOR is true then colors are preserved regardless
    color_enabled=false
    reset=""
  fi

  cecho_usage() {
    cecho "cecho: echo text with " -b --cyan "color" " and " -bu "style"
    cecho "\nUsage: cecho [options] <text>"
    cecho "\nExample: cecho --red -b \"Hello World\""
    cecho -u "\nTEXT STYLES"
    cecho "  -b, --bold       " -b "Bold or increased intensity"
    cecho "  -f, --faint      " -f "Faint, decreased intensity, or dim"
    cecho "  -i, --italic     " -i "Italic"
    cecho "  -u, --underline  " -u "Underline"
    cecho -u "\nCOLORS"
    local color padding
    for color in black red green yellow blue magenta cyan white; do
      padding=$(printf '%*s' $((12 - ${#color})) "")
      cecho "  --$color $(_padding "$color", 12) " --$color "$color color $(_padding "$color" 8) (" --$color -B "bright" ")"
    done
    cecho "  -B, --bright   Bright color variant"
    cecho -u "\nOTHER"
    cecho "  -n             Do not output the trailing newline"
    cecho "  -h, --help     Show this help and exit"
  }

  declare -A codes=(["--black"]="30" ["--red"]="31" ["--green"]="32" ["--yellow"]="33" ["--blue"]="34" ["--magenta"]="35" ["--cyan"]="36" ["--white"]="37" ["-b"]="1" ["--bold"]="1" ["-f"]="2" ["--faint"]="2" ["-i"]="3" ["--italic"]="3" ["-u"]="4" ["--underline"]="4" ["-n"]="" ["-B"]="")

  apply_styles() {
    for style in "${styles[@]}"; do
      if [[ "$color_enabled" == true ]]; then
        output+="\033[$([[ "$is_bright" == true && "$style" =~ ^3[0-7]$ ]] && echo "9${style: -1}" || echo "$style")m"
      fi
    done
    styles=()
  }

  while (($#)); do
    param="$1"
    shift
    if [[ "$param" == "--help" ]]; then
      cecho_usage
      return 0
    elif [[ "$param" == "-B" ]]; then
      is_bright=true
    elif [[ "$param" == "-n" ]]; then
      suffix=""
    elif [[ "$param" =~ ^-[a-zA-Z]{2,}$ ]]; then # Detect bundled short options
      for ((i = 1; i < ${#param}; i++)); do
        char="-${param:$i:1}"
        if [[ "$char" == "-B" ]]; then
          is_bright=true
        elif [[ "$char" == "-n" ]]; then
          suffix=""
        elif [[ "${codes[$char]+_}" ]]; then
          styles+=("${codes[$char]}")
        else
          echo "Unknown option: $char" >&2
          return 1
        fi
      done
    elif [[ -n "$param" && "${codes[$param]+_}" ]]; then
      styles+=("${codes[$param]}")
    else
      [[ "${#styles[@]}" -ne 0 ]] && apply_styles
      output+="$param$reset"
    fi
  done
  echo -en "${output}${suffix}"
}

clipboard() {
  set -euo pipefail

  clipboard_usage() {
    cecho -b "clipboard" ": copy text to clipboard"
    cecho "\nUsage: clipboard [options] <text>"
    cecho -u "\nEXAMPLES"
    cecho "  $ clipboard foo"
    cecho "  $ echo foo | clipboard"
    cecho -u "\nOPTIONS"
    cecho "  -h, --help      Show this help and exit"
  }

  while (($#)); do
    case "$1" in
    -h | --help)
      clipboard_usage
      return 0
      ;;
    *) break ;;
    esac
  done

  local input
  if read -t 0; then # checking if there is any data on STDIN
    input=$(cat)     # if yes, read it
  else
    input="$@" # else, use arguments as input
  fi

  if command -v pbcopy >/dev/null; then
    echo -n "$input" | pbcopy
  else
    cecho --yellow -fn "Warn: Clipboard command not available, tried to copy: "
    cecho --yellow -b "$input"
    return
  fi
}

section() {
  set -euo pipefail
  cecho -Bbu "\n$1"
}

step() {
  set -euo pipefail

  local command="" command_exit_code command_output="" description="" with_output=0

  step_usage() {
    echo "step [--with-output] \"DESCRIPTION\" \"COMMAND\""
    echo ""
    echo "Performs a step described by DESCRIPTION by executing COMMAND."
    echo "--with-output causes command output to be displayed as command runs, otherwise output is only shown if the command exits non-zero"
    echo "DEBUG=true forces command output to always be shown"
  }

  while (("$#")); do
    case "$1" in
    -h | --help)
      check_usage
      return 0
      ;;
    -o | --with-output)
      with_output=1
      shift
      ;;
    -* | --*)
      echo "Error: Unsupported flag $1" >&2
      step_usage
      return 1
      ;;
    *)
      if [[ -z $description ]]; then
        description=$1
      else
        command=$1
      fi
      shift
      ;;
    esac
  done

  if [[ -z $description ]] || [[ -z $command ]]; then
    step_usage
    return 1
  fi

  if ((with_output)); then
    cecho -f ">"
    set +e
    eval "${command}"
    command_exit_code=$?
    set -e
  else
    cecho -n "• ${description}"
    set +e
    command_output=$(eval "${command} 2>&1")
    command_exit_code=$?
    set -e
  fi

  if ((with_output)); then
    if [[ ${command_exit_code} -eq 0 ]]; then
      cecho "• ${description}" --green -bB " ✓"
      debug_log "> Executed: ${command}"
    else
      cecho "• ${description}" --red -bB " x"
      cecho --red "> Executed: " --red -b "${command}"
      debug_log "Done with '${description}', exited ${command_exit_code}"
    fi
  else
    if [[ ${command_exit_code} -eq 0 ]]; then
      cecho --green -bB " ✓"
      debug_log "> Executed: ${command}"
      debug_log "${command_output}"
    else
      cecho --red -bB " x"
      cecho --red "> Executed: " --red -b "${command}"
      cecho --red "${command_output}"
      debug_log "Done with '${description}', exited ${command_exit_code}"
    fi
  fi
  return ${command_exit_code}
}

check() {
  set -euo pipefail

  local command="" command_exit_code description="" remedy=""

  check_usage() {
    echo "check \"DESCRIPTION\" \"COMMAND\" \"REMEDY\""
    echo ""
    echo "Performs a check described by DESCRIPTION by executing COMMAND."
    echo "If the check fails the proposed REMEDY is shown"
  }

  while (($#)); do
    case "$1" in
    -h | --help)
      check_usage
      return 0
      ;;
    -* | --*)
      echo "Error: Unsupported flag $1" >&2
      step_usage
      return 1
      ;;
    *)
      if [[ -z $description ]]; then
        description="$1"
      elif [[ -z $command ]]; then
        command="$1"
      else
        remedy="$1"
      fi
      shift
      ;;
    esac
  done

  if [[ -z $description ]] || [[ -z $command ]] || [[ -z $remedy ]]; then
    step_usage
    return 1
  fi

  cecho -n "• ${description}"

  set +e
  command_output=$(eval "${command} 2>&1")
  command_exit_code=$?
  set -e

  if [[ ${command_exit_code} -eq 0 ]]; then
    cecho --green -bB " ✓"
    debug_log "> Executed: ${command}"
    debug_log "${command_output}"
  else
    cecho --red -bB " x"
    cecho --red "> Executed: " --red -b "${command}"
    cecho --red "${command_output}"
    debug_log "Done with '${description}', exited ${command_exit_code}"
    cecho ""
    cecho --yellow "Suggested remedy: " --yellow -b "${remedy}"
    cecho --yellow -b "${remedy}"
    clipboard "${remedy}"
    cecho --yellow "(Copied to clipboard)"
  fi
  return ${command_exit_code}
}

debug_log() {
  set -euo pipefail

  if [[ ${DEBUG:-false} == "true" ]]; then
    cecho -f "DEBUG: " "$1"
  fi
}

_padding() {
  local input="$1" total_length="$2"
  local input_length="${#input}"
  local padding_length=$((total_length - input_length))
  printf '%*s' "$padding_length"
}

_pad() {
  local padding=$(_padding "$1" "$2")
  echo -n "$1$padding"
}

_leftpad() {
  local padding=$(_padding "$1" "$2")
  echo -n "$padding$1"
}
